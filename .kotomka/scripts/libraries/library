#! /usr/bin/env bash

#-------------------------------------------------------------------------------
# Copyright (c) 2022.
# Все права защищены.
#
# Автор: Zeleza
# Email: mail @ zeleza точка ru
#
# Все права защищены.
#
# Продукт распространяется под лицензией Apache License 2.0
# Текст лицензии и его основные положения изложены на русском
# и английском языках, по ссылкам ниже:
#
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.ru
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.en
#
# Перед копированием, использованием, передачей или изменением
# любой части настоящего кода обязательным условием является
# прочтение и неукоснительное соблюдение всех, без исключения,
# статей, лицензии Apache License 2.0 по вышеуказанным ссылкам.
#-------------------------------------------------------------------------------

DEV_MANIFEST_DIR_NAME=''
ROOT_PATH_ARG="${1}"
DEV_CONFIG_FILE="${ROOT_PATH_ARG}/build.conf"
. "${DEV_CONFIG_FILE}"
#set -e

PREF=''
WAITING="ЖДИТЕ"

GPT_TOKEN=@GPT_TOKEN

#-------------------------------------------------------------------------------
# Ширина всех окна, в котором будут отображаться все сообщения скрипта
#-------------------------------------------------------------------------------
LENGTH=84

#-------------------------------------------------------------------------------
# Относительные к корневой директории проекта пути
# к файлам источникам (файлам разработки)
#-------------------------------------------------------------------------------

# Корневой путь до папки с исходными кодами
DEV_ROOT_PATH=./code

# Имя папки в которой будут лежать исходники на C++, Cи или Bash
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ${DEV_ROOT_PATH}/${DEV_SRC_REL_PATH}
DEV_SRC_PATH=src

# Имя папки в которой будут лежать файлы манифеста для исходников
# в которой будут размещены все файлы, которые
# необходимы в процессе сборки файла манифеста Makefile, как
# например, postinist или postrm. Это сделано намеренно, для
# удобства, чтобы была возможность писать скрипты в отдельном файле.
#
# Полный путь будет следующим
# ${DEV_ROOT_PATH}/${DEV_COMPILE_NAME}/

DEV_COMPILE_NAME=

#-------------------------------------------------------------------------------
# ВАЖНО!
# Задание пустого значения любой из папок ниже
# предотвращает ее создание
#-------------------------------------------------------------------------------

# Имя папки в которой будут лежать исходники на Bash повторяющие
# структуру директорий устройства на котором установлена entware
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ${DEV_ROOT_PATH}/${DEV_OPT_PATH}
DEV_OPT_PATH=files/opt

# Имя папки в которой будут лежать тесты на Bash (под bats).
# Эти тесты служат для удаленного запуска на устройстве
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ../${DEV_REMOTE_TESTS_NAME}
DEV_REMOTE_TESTS_NAME=../../tests/remote

# Имя папки в которой будут лежать собранные из исходников
# под различные архитектуры пакеты с расширением ipk.
# Папка будет находится в папке верхнего уровня
# Полный путь будет следующим ../${DEV_SRC_NAME}
DEV_IPK_NAME=../../packages

APPS_ROOT=@APPS_ROOT
DEVELOP_EXT=@DEVELOP_EXT

#APP_NAME=$(pwd | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)
APP_NAME=$PACKAGE_NAME
PACKAGES_PATH="${APPS_ROOT}/${APP_NAME}/${DEV_IPK_NAME//..\//}"

#-------------------------------------------------------------------------------
# Данные учетной записи от имени которой собираем пакет
#-------------------------------------------------------------------------------
USER=kotomka
GROUP=sudo
U_ID=5001
G_ID=5001

#-------------------------------------------------------------------------------
#  Устанавливаем права на папку и все ее содержимое для заданного имени и группы
#   $1 - путь до папки
#   $2 - пользователь
#   $3 - группа
#-------------------------------------------------------------------------------
set_user_group_for_path(){

	local path=${1} user=${2} uid=${3} group=${4} gid=${5}

	# Создаем их, если не существуют
	SUDO=""; command -v sudo &>/dev/null && SUDO=sudo
#	Проверяем группу и ее id
	if getent group ${group} >/dev/null 2>&1 ; then
		[ "$(getent group ${group} | cut -d: -f3)" != ${gid} ] && ${SUDO} groupmod -g ${gid} ${group}
	else
		${SUDO} groupadd -g ${gid} ${group} >/dev/null 2>&1
	fi

#	проверяем пользователя и его id
	if id ${user} >/dev/null 2>&1 ; then
		[ "$(id -u ${user})" != ${uid} ] && ${SUDO} usermod -u ${uid} ${user}
	else
		${SUDO} useradd -m ${uid} -g ${group} -M ${user} >/dev/null 2>&1
	fi

#	Устанавливаем права на папку сборки, пользователя, который должен быть по умолчанию
	[ -d "${path}" ] && chown -R ${user}:${group} ${path} >/dev/null 2>&1

}

#-------------------------------------------------------------------------------
#  Копируем содержимое файла при этом создаем папку назначения есть ее нет
#-------------------------------------------------------------------------------
copy_file() {
	[ -d "${2}" ] || mkdir -p "${2}"
	[ -f "${1}" ] && run_then "cp -f ${1} ${2}" "Копируем файл ${GREEN}${1}${NOCL} в папку ${BLUE}${2}${NOCL}"
}


#-------------------------------------------------------------------------------
#  Создаем папку если ее нет
#-------------------------------------------------------------------------------
mkdir_when_no(){
    [ -d "${1}" ] || mkdir -p "${1}"
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_ynq() {
    header="${1}"
#	в случае, если встретиться слово с корнем "удал", то цвет заголовка - красный
	while true; do
		printf "${header}"
		read -r ynq
		case "${ynq}" in
			[Yy]* ) eval "${2}=y"; break; ;;
			[NnQq]* ) eval "${2}=n"; break; ;;
			     *) printf "Пожалуйста ответьте на вопрос 'Y' - да или 'N' - нет, Q - выход\n"
			;;
		esac
	done
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - максимальное число позиций в списке
# 	 $3 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_choice(){

    header="${1}";
    max_count=${2}

    while true; do
        printf "${header} "
        read -r choice
        case "${choice}" in
            [1-"${max_count}"] ) eval "${3}=${choice}"; break; ;;
            [Qq]* ) eval "${3}=q"; break; ;;
                 *) printf "Пожалуйста введите число от 1 до ${max_count} или Q для выхода.\n"
            ;;
        esac
    done


}


#-------------------------------------------------------------------------------
# Получаем необходимую информацию о версии пакета
#-------------------------------------------------------------------------------
get_version_part(){

	value=${1}
	make_file="${ROOT_PATH_ARG}/${DEV_ROOT_PATH//./}/Makefile"

	if [ "${value}" = PACKAGE_VERSION ]; then cat < "${make_file}" | sed -n "s/PKG_VERSION:=\(.*\)/\1/p"; fi
	if [ "${value}" = PACKAGE_STAGE ]; 	 then cat < "${make_file}" | sed -n "s/PKG_RELEASE:=\([a-zA-Z]\{3,\}\).*/\1/p"; fi
	if [ "${value}" = PACKAGE_RELEASE ]; then cat < "${make_file}" | sed -n "s/PKG_RELEASE:=.*\([0-9]\{1,3\}\)/\1/p"; fi

}


#-------------------------------------------------------------------------------
# Получаем значение из скрытого файла конфигурации
#-------------------------------------------------------------------------------
get_config_value(){
  cat < "${DEV_CONFIG_FILE}" | grep -E "^${1}=" | cut -d'=' -f2
}

#-------------------------------------------------------------------------------
# Получаем имя приложения из названия корневой папки
#-------------------------------------------------------------------------------
#APP_NAME=$(echo "${BASEDIR}" | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)

#-------------------------------------------------------------------------------
# Получаем имя пакета для сборки
#-------------------------------------------------------------------------------
get_full_package_version(){

	package_version=$(get_version_part PACKAGE_VERSION)
	package_stage=$(get_version_part PACKAGE_STAGE)
	package_release=$(get_version_part PACKAGE_RELEASE)

	if [ -n "${package_stage}" ] ; then stg="-${package_stage}"; else stg=""; fi
	if [ -n "${package_release}" ] ; then rel="-${package_release}"; else rel=""; fi
	echo "${package_version}${stg}${rel}"
}


#-------------------------------------------------------------------------------
# Получаем имя пакета ipk файла для сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_name(){
	echo "${APP_NAME}_$(get_full_package_version)_${ARCH_BUILD}.ipk"
}

#-------------------------------------------------------------------------------
# Получаем полный путь до пакета сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_file(){
    echo "${APPS_ROOT}/entware/bin/targets/${ARCH_BUILD}/generic-glibc/packages/$(get_ipk_package_name)"
}

#-------------------------------------------------------------------------------
# Осуществляем вход по ssh с определенными по умолчанию параметрами
# ConnectTimeout 			- Время ожидания чтобы "достучаться"
# StrictHostKeyChecking 	- В случае первого входа - сразу согласится с входом, без запроса
# PasswordAuthentication 	- Не запрашивать пароль при входе, требуется для проверки соединения.
#-------------------------------------------------------------------------------
run_ssh(){
#set -x
	dev=${2}; port=${1}; cmd=${3};
	ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no -p "${port}" "root@${dev}" "${cmd}"
}


#-------------------------------------------------------------------------------
# Осуществляем проверку на доступность IP или доменного имени
#	$1 - ip устройства
#	$2 - порт устройства
#	Возвращает yes - в случае, если устройство доступно
#			   no  - в случае, если устройство НЕ доступно
#-------------------------------------------------------------------------------
is_device_alive(){

	dev=${1}; port=${2}
	ssh -o ConnectTimeout=2 \
		-o StrictHostKeyChecking=no \
		-o PasswordAuthentication=no \
		-p "${port}" "root@${dev}" 'exit 0' 2>&1 | grep -q 'Connection timed out' && echo no || echo yes
}


#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root' || echo "${HOME}")
	key_file_pub="${key_path}/.ssh/${key_name}.pub"
	key_file_prv="${key_path}/.ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим удаление и установку пакета
#-------------------------------------------------------------------------------
run_reinstalation_on_router(){

	dev_ip=${1}; dev_port=${2}

	ready "${PREF}Производим удаление пакета с устройства"
	run_ssh "${dev_port}" "${dev_ip}" 'opkg remove '"${APP_NAME}" &>/dev/null && when_ok || when_err

	ready "${PREF}Производим установку пакета на устройство" "" true false
	print_line_sim "-" 0
	cmd='[ -d /opt/packages ] || mkdir /opt/packages; opkg install /opt/packages/'"$(get_ipk_package_name)"
	run_ssh "${dev_port}" "${dev_ip}" "${cmd}" #&>/dev/null && when_ok || when_err
	print_line
}


#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root/.' || echo "${HOME}/.")
	key_file_pub="${key_path}ssh/${key_name}.pub"
	key_file_prv="${key_path}ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Копируем публичный ключ на роутер
#-------------------------------------------------------------------------------
copy_ssh_keys_to_router(){
	dev_ip=${1}; dev_port=${2}

	# если ключи отсутствуют на NAS
	ready "${PREF}Копируем ключи на роутер ${dev_ip} порт ${dev_port}..."
	run_ssh "${dev_port}" "${dev_ip}" "echo \"$(cat "$(get_key_file)")\" >> /opt/root/.ssh/authorized_keys" && when_ok || when_err
	print_line
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим копирование собранного пакета на роутер
#-------------------------------------------------------------------------------
copy_app_to_router(){

	dev_ip=${1}; dev_port=${2}
#	print_line
#	создаем папку на устройстве для хранения упакованного пакета
	run_ssh "${dev_port}" "${dev_ip}" '[ -d /opt/packages ] || mkdir -p /opt/packages'
	app_tar_name=$(get_ipk_package_name)
	ipk_file=$(get_ipk_package_file)

#	удаляем предыдущий файл этой же версии пакета, если он там был и перемещаем его из контейнера на устройство

	ready "${PREF}Копируем пакет на устройство..."

	if ! [ -f "${PACKAGES_PATH}/${app_tar_name}" ]; then
		if ! [ -f "${ipk_file}" ]; then
			print_error "Файл ${ipk_file}"
			print_error "не найден в целевом целевом контейнере."
			exit 1
		else
			cp "${ipk_file}" "${PACKAGES_PATH}/" || \
				print_error "Произошла ошибка при копировании файла"
				print_error "${ipk_file}"
				exit 1
		fi
	fi
	{
		echo -n ''
		run_ssh "${dev_port}" "${dev_ip}" 'rm -f '"/opt/packages/${app_tar_name}" &> /dev/null
		scp -P "${dev_port}" "${PACKAGES_PATH}/${app_tar_name}" "root@${dev_ip}:/opt/packages/${app_tar_name}" &> /dev/null
	}  && when_ok || when_err

}


#-------------------------------------------------------------------------------
# Экранируем символы '/' в строке для передачи в sed
#-------------------------------------------------------------------------------
escape()(echo "${1}" | sed 's|\/|\\/|g')


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Получаем архитектуру текущего устройства
#-------------------------------------------------------------------------------
get_device_arch(){

	dev_ip=${1}; dev_port=${2}
	cmd_get_arch="cat /opt/etc/opkg.conf | sed -n 's/^arch.\([a-zA-Z]\{1,\}[0-9]\{0,2\}-[0-9]\{1,2\}\.[0-9]\{0,2\}\).*$/\1/p;' | head -1"
	run_ssh "${dev_port}" "${dev_ip}" "${cmd_get_arch}"
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запускаем тесты на роутере из контейнера
#-------------------------------------------------------------------------------
run_tests(){
    cd "${APPS_ROOT}/${APP_NAME}"/${DEV_REMOTE_TESTS_NAME//..\//} || exit 1
    ./tests.run
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запрашиваем разрешение на запуск тестов на роутере из контейнера
#-------------------------------------------------------------------------------
ask_run_tests(){
    answer=''; read_ynq "${PREF}Запустить тесты прямо сейчас [Y/N/Q]? " answer
    [ "${answer}" = y ] && run_tests
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Вычисляем время между двумя временами в секундах
# и выводим время в виде ЧЧ:MM:CC
#-------------------------------------------------------------------------------
time_diff(){
    one_time=${1}
    two_time=${2}

    diff_sec=$((two_time - one_time))
    dd=$((diff_sec/86400))
    hh=$((diff_sec / 3600))
    mm=$((diff_sec / 60))
    ss=$((diff_sec % 60))

    if [ "${dd}" = 0 ]; then DD=''; else DD="${dd} дн. "; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] ; then HH=''; else HH=" ${hh} ч."; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] && [ "${mm}" = 0 ] ; then MM=''; else MM=" ${mm} мин."; fi

    echo "${DD}${HH}${MM} ${ss} сек."
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
#
# 	Копируем пакет на роутер и производим его установку
#
# 	$1 - в случае значения ask - выводим вопрос о проведении тестов,
#	   		 при иных значениях - тесты пропускаем
#
#-------------------------------------------------------------------------------
copy_and_install_package(){
#set -x
    tests_ask=${1:-no}

    for dev in ${ROUTER_LIST} ; do
#    	получаем адрес и порт (по умолчанию - 222)
    	dev_ip=$(echo "${dev}" | cut -d':' -f1 )
    	dev_port=$(echo "${dev}" | cut -d':' -f2)
    	[ "${dev_port}" = "${dev_ip}" ] && dev_port=222

		ready "${PREF}Устройство по адресу ${GREEN}${dev_ip}:${dev_port}${NOCL}..."
		# проверяем на доступность ip роутера
		if [ "$(is_device_alive "${dev_ip}" "${dev_port}")" = yes ]; then

			when_ok "ДОСТУПНО"
			# 	Проверяем есть ли ключ на роутере
			docker_key=$(cat < "$(get_key_file)")
			run_ssh "${dev_port}" "${dev_ip}" 'cat /opt/root/.ssh/authorized_keys' | grep -q "${docker_key}" || {
					print_line
					copy_ssh_keys_to_router "${dev_ip}" "${dev_port}"
			}

	#    	текущая архитектура на устройстве
			dev_arch=$(get_device_arch "${dev_ip}" "${dev_port}")
	#    	текущая архитектура в контейнере (просто название без версии )
			container_arch=$(echo "${ARCH_BUILD}" | sed -n 's|^\([a-zA-Z]\{4,\}\)[0-9]\{0,2\}\(-[0-9]\{1,2\}.[0-9]\{1,2\}\).*|\1|p')

			if [ "${ARCH_BUILD}" = "${dev_arch}" ]; then
				# копируем собранный пакет на роутер
				copy_app_to_router "${dev_ip}" "${dev_port}"
	#				запускаем установку пакета
				run_reinstalation_on_router "${dev_ip}" "${dev_port}"

				# Запускаем тесты
				case "${tests_ask}" in
					YES|Yes|yes|y ) run_tests ;;
					ASK|Ask|ask|a )
						print_line
						answer=''; read_ynq "Запустить исполнение тестов на устройстве? " answer
						if [ "${answer}" = y ]; then run_tests; else print_line ; fi
						;;
					* ) ;;

				esac
			else
				echo -ne "${PREF}Устройство имеет архитектуру ${BLUE}${dev_arch}${NOCL}"
				when_err "ПРОПУСКАЕМ"
				print_line
			fi

		else
			when_err "НЕДОСТУПНО"
			print_line
		fi

	done

}
