#!/bin/sh

#---------------------------------------------------------------------------------
#
#   Библиотека функций для busybox для работы
#   с экраном терминала текущей из сессии
#
#   Автор       : Железа
#   Email       : dev@zeleza.ru
#   Лицензия    : Apache Версия 2.0, январь 2004
#
#   Создан      : 05 февраля 2024 год
#   Обновлен    : 05 февраля 2024 год
#
#---------------------------------------------------------------------------------
APP_SCREEN_WIDTH=84

#set_screen_globals() {
##---------------------------------------------------------------------------------
##   Установка глобальных переменных для вывода символов
##---------------------------------------------------------------------------------
#
##   ширина экрана терминала
#    SCREEN_WIDTH=$(get_screen_width)
#
##   ширина экрана рабочей области в рамках которой
##   происходит вывод информации о всех процессах программы
#    APP_SCREEN_WIDTH=$((SCREEN_WIDTH * 2 / 3))
#    # если ширина экрана меньше 81 символа, то задаем
#    # минимальное число символов в строке
#    if [ "${SCREEN_WIDTH}" -le 84 ] && APP_SCREEN_WIDTH=68 ; then
#}

set_esc_colors() {
#---------------------------------------------------------------------------------
#   Установка видимых в исполняемом файле переменных 
#   управляющих-последовательностей для работы с экраном
#   которые отвечают за управление цветами выводимых символов на экран
#---------------------------------------------------------------------------------

#   Управление текстом 
    YELLOW="\e[33m"              # желтый цвет текста
    BLUE="\e[36m"                # синий цвет текста
    RED="\e[01;31m"              # красный цвет текста
    UD_BRITE="\e[4;92m"          # ярко-зеленый подчеркнутый цвет текста
    BL_BRITE="\e[1;92m"          # ярко-зеленый жирный цвет текста
    BOLD="\e[1m"          		 # жирный цвет текста
    GREEN="\e[32m"               # темно зеленый цвет текста
    NOCL="\e[m"                  # возвращает текст к настройкам по умолчанию.
    BL_YEL="\e[30;43m"           # желтый фон и черный текст
    RED_WHT="\e[1;97;41m"        # красный фон и белый цвет
    BLU_WHT="\e[30;44m"          # синий фон и белый цвет
}

set_esc_sims() {
#---------------------------------------------------------------------------------
#   Установка видимых в исполняемом файле переменных
#   управляющих-последовательностей для работы с экраном
#   которые отвечают за вывод на экран спец символов
#   и символов псевдографики
#---------------------------------------------------------------------------------

#   Отображение спец символов 
    SM_OK="${GREEN}✓${NOCL}"                  # зеленая галочка - значит все хорошо
    SM_WAIT="${YELLOW}▀${NOCL}"
    SM_CROSS="${RED}✗${NOCL}"                 # красный крестик - значит ошибка
    SM_HOLD="-"                             # символ при остановке бегунка
    SM_LINE_H='═'                           # символ вертикальной линий
    SM_LINE_V='║'                           # символ горизонтальной линии
    SM_ANGLE_UL='╔'                         # символ верхнего правого угла
    SM_ANGLE_UR='╗'                         # символ верхнего правого угла
    SM_ANGLE_DL='╚'                         # символ нижнего правого угла
    SM_ANGLE_DR='╝'                         # символ нижнего правого угла
    SM_LINE_VL='╠'                          # символ горизонтальной линии с уклоном в право
    SM_LINE_VR='╣'                          # символ горизонтальной линии с уклоном в лево

}

set_esc_cursor() {
#---------------------------------------------------------------------------------
#   Установка видимых в исполняемом файле переменных
#   управляющих-последовательностей для работы с экраном
#   которые отвечают за управление курсором на экран
#---------------------------------------------------------------------------------

#   Управление курсом и очисткой экрана
    CRS_ON="\e[?25h"                      # включаем отображение курсора
    CRS_OFF="\e[?25l"                     # отключаем показ курсора

    CRS_UP1="\e[A"                        # Перемещение курсора вверх на одну строку.
    CRS_DOWN1="\e[B"                      # Перемещение курсора вниз на одну строку.
    CRS_RIGHT1="\e[C"                     # Перемещение курсора вправо на одну позицию.
    CRS_LEFT1="\e[D"                      # Перемещение курсора влево на одну позицию.
    CRS_TO1="\e[G"                        # Перемещение курсора к первому символу в строке
    CRS_MV_HM='\e[H'                      # перемещаем курсор на позицию 0,0

    CRS_SV_POS="\e[7"                     # Сохраняет текущую позицию курсора.
    CRS_LD_POS="\e[8"                     # Восстанавливает сохраненную позицию курсора.
}


set_esc_eraser() {
#---------------------------------------------------------------------------------
#   Установка видимых в исполняемом файле переменных
#   управляющих-последовательностей для работы с экраном
#   которые отвечают за стирание позиций на экране
#---------------------------------------------------------------------------------
    CRS_CES_CL="\e[0J"                      # стереть от курсора до конца экрана
    CRS_CBS_CL="\e[1J"                      # стереть от курсора до начала экрана
    CRS_SCR_CL="\e[2J"                      # стереть полностью весь экран
    CRS_SVS_CL="\e[3J"                      # стереть сохраненные строки

    CRS_CTE_CL="\e[0K"                      # очищаем от курсора до конца строки
    CRS_ETC_CL="\e[1K"                      # очищаем от начала строки до курсора
    CRS_STR_CL="\e[2K"                      # очищаем текущую строку полностью

}

get_screen_high(){
#---------------------------------------------------------------------------------
#   Получение высоты терминального окна
#---------------------------------------------------------------------------------
    stty size | cut -d' ' -f1
}

get_screen_width(){
#---------------------------------------------------------------------------------
#   Получение ширины терминального окна
#---------------------------------------------------------------------------------

    stty size | cut -d' ' -f2
}

print_line(){
#---------------------------------------------------------------------------------
#   Печатаем строку заданных символов длинной заданной в переменной LEN_LINE
#   $1 - задаем число символов линии для печати [по умолчанию: "APP_SCREEN_WIDTH"]
#   $2 - задаем символ для печати [по умолчанию: "-"]
#---------------------------------------------------------------------------------
#    set_screen_globals
    local _length=${1:-${APP_SCREEN_WIDTH}}
    printf "%.0s${2:-═}" $(seq 1 ${_length}); echo
}

clean_escape(){
#---------------------------------------------------------------------------------
#   Очистка строки от управляющих символов
#   $1 - срока для очистки
#---------------------------------------------------------------------------------
	# Очистка строки от управляющих символов
	printf "%s" "${1}" | sed 's/\x1B\[[0-9;]*[a-zA-Z]//g'
}

#-------------------------------------------------------------------------------
#
#	 Вспомогательные функции печати в лог отладки
#
#-------------------------------------------------------------------------------
#	Печать текста с выравниванием по центру
# 	$1 - текст
# ------------------------------------------------------------------------------------------
center() {
	local _len="${#1}"
	diff=$((LENGTH-_len))
  	right=$((diff/2))
  	left=$((diff - right))
  	text=$(printf "%*s%s%*s\n" "${left}" "" "${1}" "${right}" "")
  	printf "${text}\n" | fold -w ${SCREEN_WIDTH}
}


#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_err
#
#  $1 - передаваемый текст (обязательный параметр)
#-------------------------------------------------------------------------------
print_info() {
	printf "${GREEN}${1}${NOCL}" | fold_text
}


#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом (КРАСНЫМ) о неуспехе
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_err
#
#  $1 - передаваемый текст (обязательный параметр)
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${RED}
#-------------------------------------------------------------------------------
print_error() {
	printf "${RED}${1}${NOCL}" | fold_text
}

#-------------------------------------------------------------------------------
#  Печатаем сообщение-предупреждение заданного цвета (ГОЛУБЫМ)
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_err
#
#  $1 - передаваемый текст
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${BLUE}
#-------------------------------------------------------------------------------
print_warning() {
	 printf "${BLUE}${1}${NOCL}" | fold_text
}

#-------------------------------------------------------------------------------
#  Печатаем строку c форматированием по заданной ширине или
#  APP_SCREEN_WIDTH - по умолчанию
#
#  $1 - передаваемый текст
#  $2 - ширина отсечения текста, по умолчанию ${APP_SCREEN_WIDTH}
#-------------------------------------------------------------------------------
fold_text() {
    local max_line_length="$1"
    local formatted_text=""

    while IFS= read -r -d '' line; do
        while [ -n "$line" ]; do
            formatted_text+="${line:0:max_line_length}\n"
            line="${line:max_line_length}"
        done
    done

    printf "${formatted_text}"
}

