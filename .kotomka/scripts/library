#! /usr/bin/env bash

#-------------------------------------------------------------------------------
# Copyright (c) 2022.
# Все права защищены.
#
# Автор: Zeleza
# Email: mail @ zeleza точка ru
#
# Все права защищены.
#
# Продукт распространяется под лицензией Apache License 2.0
# Текст лицензии и его основные положения изложены на русском
# и английском языках, по ссылкам ниже:
#
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.ru
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.en
#
# Перед копированием, использованием, передачей или изменением
# любой части настоящего кода обязательным условием является
# прочтение и неукоснительное соблюдение всех, без исключения,
# статей, лицензии Apache License 2.0 по вышеуказанным ссылкам.
#-------------------------------------------------------------------------------

DEV_MANIFEST_DIR_NAME=''
DEV_CONFIG_FILE="${1}/build.conf"
. "${DEV_CONFIG_FILE}"
#set -e

RED="\033[1;31m";
GREEN="\033[1;32m";
BLUE="\033[36m";
YELLOW="\033[33m";
NOCL="\033[m";
PREF='>> '


#-------------------------------------------------------------------------------
# Относительные к корневой директории проекта пути
# к файлам источникам (файлам разработки)
#-------------------------------------------------------------------------------

# Корневой путь до папки с исходными кодами
DEV_ROOT_PATH=./code

# Имя папки в которой будут лежать исходники на C++, Cи или Bash
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ${DEV_ROOT_PATH}/${DEV_SRC_REL_PATH}
DEV_SRC_PATH=src

# Имя папки в которой будут лежать файлы манифеста для исходников
# в которой будут размещены все файлы, которые
# необходимы в процессе сборки файла манифеста Makefile, как
# например, postinist или postrm. Это сделано намеренно, для
# удобства, чтобы была возможность писать скрипты в отдельном файле.
#
# Полный путь будет следующим
# ${DEV_ROOT_PATH}/${DEV_COMPILE_NAME}/

DEV_COMPILE_NAME=

#-------------------------------------------------------------------------------
# ВАЖНО!
# Задание пустого значения любой из папок ниже
# предотвращает ее создание
#-------------------------------------------------------------------------------

# Имя папки в которой будут лежать исходники на Bash повторяющие
# структуру директорий устройства на котором установлена entware
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ${DEV_ROOT_PATH}/${DEV_OPT_PATH}
DEV_OPT_PATH=files/opt

# Имя папки в которой будут лежать тесты на Bash (под bats).
# Эти тесты служат для удаленного запуска на устройстве
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ../${DEV_REMOTE_TESTS_NAME}
DEV_REMOTE_TESTS_NAME=../../tests/remote

# Имя папки в которой будут лежать собранные из исходников
# под различные архитектуры пакеты с расширением ipk.
# Папка будет находится в папке верхнего уровня
# Полный путь будет следующим ../${DEV_SRC_NAME}
DEV_IPK_NAME=../../packages


APPS_ROOT=/apps
APP_NAME=$(pwd | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)
PACKAGES_PATH="${APPS_ROOT}/${APP_NAME}/${IPK_PATH//..\//}"

#-------------------------------------------------------------------------------
# Данные учетной записи от имени которой собираем пакет
#-------------------------------------------------------------------------------
USER=master; GROUP=staff; U_ID=5001; G_ID=5001

#-------------------------------------------------------------------------------
#  Копируем содержимое файла при этом создаем папку назначения есть ее нет
#-------------------------------------------------------------------------------
copy_file() {
	[ -d "${2}" ] || mkdir -p "${2}"
	ready "Копируем ${1} в папку ${2}"
    cp -f "${1}" "${2}"
}


#-------------------------------------------------------------------------------
#  Создаем папку если ее нет
#-------------------------------------------------------------------------------
mkdir_when_not(){
    [ -d "${1}" ] || mkdir -p "${1}"
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_ynq() {
    header="${1}"
#	в случае, если встретиться слово с корнем "удал", то цвет заголовка - красный
	while true; do
		echo -en "${header}"
		read -r ynq
		case "${ynq}" in
			[Yy]* ) eval "${2}=y"; break; ;;
			[NnQq]* ) eval "${2}=n"; break; ;;
			     *) echo -e "Пожалуйста ответьте на вопрос 'Y' - да или 'N' - нет, Q - выход"
			;;
		esac
	done
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - максимальное число позиций в списке
# 	 $3 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_choice(){

    header="${1}";
    max_count=${2}

    while true; do
        echo -n "${header} "
        read -r choice
        case "${choice}" in
            [1-"${max_count}"] ) eval "${3}=${choice}"; break; ;;
            [Qq]* ) eval "${3}=q"; break; ;;
                 *) echo -e "Пожалуйста введите число от 1 до ${max_count} или Q для выхода."
            ;;
        esac
    done


}


#-------------------------------------------------------------------------------
#
#	 Вспомогательные функции печати в лог отладки
#
#-------------------------------------------------------------------------------
LENGTH=86
#-------------------------------------------------------------------------------
#  Вычисляем разницу между длинной переданной строки и
#  заданной шириной печати - LENGTH
#-------------------------------------------------------------------------------
diff_len() {
	charlen=$(echo "${1}" | sed -r "s/[\]033\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g")
	charlen=${#charlen}
	echo $(( LENGTH - charlen ))
}


# ------------------------------------------------------------------------------------------
#	Печать текста с выравниванием по центру
# 	$1 - текст
# ------------------------------------------------------------------------------------------
center() {
	diff=$((LENGTH-${#1}))
  	right=$((diff/2))
  	left=$((diff - right))
  	text=$(printf "%*s%s%*s\n" "${left}" "" "${1}" "${right}" "")
  	echo -e "${text}"
}


#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом (ЗЕЛЕНЫМ) об успехе
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст (обязательный параметр)
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#  $3 - фаг указывает на наличие печати новой строки после текста
#-------------------------------------------------------------------------------
ready() {

	[ -z "${1}" ] && (echo "Отсутствует текст сообщения!"; exit 1)
	if [ -z "${2}" ]; then _color=${GREEN}; else _color=${2}; fi
	if [ "${3}" = true ]; then new_line='\n'; else new_line=''; fi
	text=$(echo "${1}" | tr "[:lower:]" "[:upper:]")
	text="${_color}${text}${NOCL}"
	size=$(diff_len "${text}")
	printf "%b%-${size}s%b${new_line}" "${text}"

}

#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом (КРАСНЫМ) о неуспехе
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст (обязательный параметр)
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${RED}
#-------------------------------------------------------------------------------
error() {
	ready "${1}" "${RED}" 'true'
}

#-------------------------------------------------------------------------------
#  Печатаем сообщение-предупреждение заданного цвета (ГОЛУБЫМ)
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${BLUE}
#-------------------------------------------------------------------------------
warning() {
	ready "${1}" "${BLUE}" 'true'
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена с каким либо результатом
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#-------------------------------------------------------------------------------
show_result() {
	[ -z "${1}" ] && text='OK' || text=${1}
	[ -z "${2}" ] && color="${BLUE}" || color=${2}
	text=$(echo "${1}" | tr "[[:lower:]]" "[[:upper:]]")
  	echo -e "${color}${text}${NOCL}"
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена УСПЕШНО!
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#-------------------------------------------------------------------------------
when_ok() {
	[ -z "${1}" ] && text='ГОТОВО' || text=${1}
	show_result "${text}" "${GREEN}"
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена С ОШИБКОЙ!
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#-------------------------------------------------------------------------------
when_bad() {
	[ -z "${1}" ] && text='OШИБКА' || text=${1}
	show_result "${text}" "${RED}"
}


#-------------------------------------------------------------------------------
# Печатаем строку из 100 знаков равно
#	$1 - символ который печатаем (по умолчанию '-')
#	$2 - число пробелов спереди  строки (по умолчанию '0')
#	$3 - длинна строки (по умолчанию '$LENGTH' символов )
#
#-------------------------------------------------------------------------------
print_line_sim(){
	len=$((LENGTH + 12))
	sim=${1:--}; nspaces=${2:-0}; len=${3:-$len}
	printf "%${nspaces}s"
	printf "%$((len - nspaces))s\n" | tr ' ' "${sim}"
}

#-------------------------------------------------------------------------------
# Печатаем строку из 100  знаков равно
#-------------------------------------------------------------------------------
show_line(){
  print_line_sim "=" 0
}


#-------------------------------------------------------------------------------
# Получаем необходимую информацию о версии пакета
#-------------------------------------------------------------------------------
get_version_part(){
	value=${1}
	cat < "${DEV_CONFIG_FILE}" | grep "${value}" | cut -d'=' -f2 | tr -d ' '
}

PACKAGE_VERSION=$(get_version_part PACKAGE_VERSION)
PACKAGE_STAGE=$(get_version_part PACKAGE_STAGE)
PACKAGE_RELEASE=$(get_version_part PACKAGE_RELEASE)

if [ -n "${PACKAGE_STAGE}" ]; then FULL_VERSION="${PACKAGE_VERSION} ${PACKAGE_STAGE} релиз ${PACKAGE_RELEASE}"; else FULL_VERSION="${PACKAGE_VERSION} релиз ${PACKAGE_RELEASE}"; fi

#-------------------------------------------------------------------------------
# Получаем значение из скрытого файла конфигурации
#-------------------------------------------------------------------------------
get_config_value(){
  cat < "${DEV_CONFIG_FILE}" | grep -E "^${1}=" | cut -d'=' -f2
}

#-------------------------------------------------------------------------------
# Получаем имя приложения из названия корневой папки
#-------------------------------------------------------------------------------
APP_NAME=$(echo "${BASEDIR}" | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)

#-------------------------------------------------------------------------------
# Получаем имя пакета для сборки
#-------------------------------------------------------------------------------
get_full_package_version(){
	if [ -n "${PACKAGE_STAGE}" ] ; then stg="-${PACKAGE_STAGE}"; else stg=""; fi
	if [ -n "${PACKAGE_RELEASE}" ] ; then rel="-${PACKAGE_RELEASE}"; else rel=""; fi
	echo "${PACKAGE_VERSION}${stg}${rel}"
}


#-------------------------------------------------------------------------------
# Получаем имя пакета ipk файла для сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_name(){
	echo "${APP_NAME}_$(get_full_package_version)_${ARCH_BUILD}.ipk"
}

#-------------------------------------------------------------------------------
# Получаем полный путь до пакета сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_file(){

    echo "${APPS_ROOT}/entware/bin/targets/${ARCH_BUILD}/generic-glibc/packages/$(get_ipk_package_name)"
}


#-------------------------------------------------------------------------------
# Осуществляем проверку на доступность IP или доменного имени
#-------------------------------------------------------------------------------
is_ip_or_host_alive(){
    ping -q -w3 "${1}" &>/dev/null
}
#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root' || echo "${HOME}")
	key_file_pub="${key_path}/.ssh/${key_name}.pub"
	key_file_prv="${key_path}/.ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим удаление и установку пакета
#-------------------------------------------------------------------------------
run_reinstalation_on_router(){
	dev_ip=${1}; dev_port=${2}

	ssh -p "${dev_port}" "root@${dev_ip}" 'opkg remove '"${APP_NAME}"
	cmd='[ -d /opt/packages ] || mkdir /opt/packages; opkg install /opt/packages/'"$(get_ipk_package_name)"
	ssh -p "${dev_port}" "root@${dev_ip}" "${cmd}" #<<< 2
}

#-------------------------------------------------------------------------------========================================
#
# 	Функции которая меняет крайнюю версию пакета в файлах собираемого пакета
# 	на основе данных из файла ./version
#
#-------------------------------------------------------------------------------========================================
change_version_in_package(){
	sed -i "s/^\(APP_VERSION=\).*/\1${PACKAGE_VERSION}/g" \
		"${APPS_ROOT}"/entware/package/utils/"${APP_NAME}"/files/bin/"${APP_NAME}"
	sed -i "s/^\(APP_RELEASE=\).*/\1${PACKAGE_STAGE}-${PACKAGE_RELEASE}/g" \
		"${APPS_ROOT}"/entware/package/utils/"${APP_NAME}"/files/bin/"${APP_NAME}"
}

#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root/.' || echo "${HOME}/.")
	key_file_pub="${key_path}ssh/${key_name}.pub"
	key_file_prv="${key_path}ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Копируем публичный ключ на роутер
#-------------------------------------------------------------------------------
copy_ssh_keys_to_router(){
	dev_ip=${1}; dev_port=${2}

	# если ключи отсутствуют на NAS
	echo "${PREF}Копируем ключи на роутер ${dev_ip} порт ${dev_port}..."
	ssh -p "${dev_port}" "root@${dev_ip}" "echo \"$(cat "$(get_key_file)")\" >> /opt/root/.ssh/authorized_keys"
	show_line
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим копирование собранного пакета на роутер
#-------------------------------------------------------------------------------
copy_app_to_router(){
	dev_ip=${1}; dev_port=${2}
	echo "${PREF}Копируем пакет на устройство и производим его установку..."
	show_line
#	создаем папку на устройстве для хранения упакованного пакета
	ssh -p "${dev_port}" "root@${dev_ip}" '[ -d /opt/packages ] || mkdir -p /opt/packages'
	app_tar_name=$(get_ipk_package_name)
#	удаляем предыдущий файл этой же версии пакета, если он там был и перемещаем его из контейнера на устройство
	ssh -p "${dev_port}" "root@${dev_ip}" 'rm -f '"/opt/packages/${app_tar_name}" #&> /dev/null
	scp -P "${dev_port}" "${PACKAGES_PATH}/${app_tar_name}" "root@${dev_ip}:/opt/packages/${app_tar_name}"

}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Получаем архитектуру текущего устройства
#-------------------------------------------------------------------------------
get_device_arch(){
	dev_ip=${1}; dev_port=${2}

	cmd_get_arch='grep "arch" /opt/etc/entware_release | cut -f2 -d"="'
	ssh -p "${dev_port}" "root@${dev_ip}" "${cmd_get_arch}"
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запускаем тесты на роутере из контейнера
#-------------------------------------------------------------------------------
run_tests(){
    cd "${APPS_ROOT}/${APP_NAME}"${DEV_REMOTE_TESTS_NAME//..\//} || exit 1
    ./tests.run
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запрашиваем разрешение на запуск тестов на роутере из контейнера
#-------------------------------------------------------------------------------
ask_run_tests(){
    answer=''; read_ynq "Запустить тесты прямо сейчас [Y/N/Q]? " answer
    [ "${answer}" = y ] && run_tests
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Вычисляем время между двумя временами в секундах
# и выводим время в виде ЧЧ:MM:CC
#-------------------------------------------------------------------------------
time_diff(){
    one_time=${1}
    two_time=${2}

    diff_sec=$((two_time - one_time))
    dd=$((diff_sec/86400))
    hh=$((diff_sec / 3600))
    mm=$((diff_sec / 60))
    ss=$((diff_sec % 60))

    if [ "${dd}" = 0 ]; then DD=''; else DD="${dd} дн. "; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] ; then HH=''; else HH=" ${hh} ч."; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] && [ "${mm}" = 0 ] ; then MM=''; else MM=" ${mm} мин."; fi

    echo "${DD}${HH}${MM} ${ss} сек."
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
#
# 	Копируем пакет на роутер и производим его установку
#
# 	$1 - в случае значения ask - выводим вопрос о проведении тестов,
#	   		 при иных значениях - тесты пропускаем
#
#-------------------------------------------------------------------------------
copy_and_install_package(){

    tests_ask=${1:-no}

    for dev in ${ROUTER_LIST} ; do
#    	получаем адрес и порт (по умолчанию - 222)
    	dev_ip=$(echo "${dev}" | cut -d':' -f1 )
    	dev_port=$(echo "${dev}" | cut -d':' -f2)
    	[ "${dev_port}" = "${dev_ip}" ] && dev_port=222

		# проверяем на доступность ip роутера
		if is_ip_or_host_alive "${dev_ip}"; then

			echo -e "${PREF}Устройство по адресу ${GREEN}${dev_ip}:${dev_port}${NOCL} доступно!"
			# 	Проверяем есть ли ключ на роутере
			docker_key=$(cat < "$(get_key_file)")
			ssh -p "${dev_port}" "root@${dev_ip}" 'cat /opt/root/.ssh/authorized_keys' | grep -q "${docker_key}" || {
					show_line
					copy_ssh_keys_to_router "${dev_ip}" "${dev_port}"
			}

	#    	текущая архитектура на устройстве
			dev_arch=$(get_device_arch "${dev_ip}" "${dev_port}")
	#    	текущая архитектура в контейнере (просто название без версии )
			container_arch=$(echo "${ARCH_BUILD}" | sed -n 's|^\([a-zA-Z]\{4,\}\)[0-9]\{0,2\}\(-[0-9]\{1,2\}.[0-9]\{1,2\}\).*|\1|p')

			if [ "${container_arch}" = "${dev_arch}" ]; then
				# копируем собранный пакет на роутер
				copy_app_to_router "${dev_ip}" "${dev_port}"
	#				запускаем установку пакета
				run_reinstalation_on_router "${dev_ip}" "${dev_port}"

				# Запускаем тесты
				case "${tests_ask}" in
					YES|Yes|yes|y ) run_tests ;;
					ASK|Ask|ask|a )
						show_line
						answer=''; read_ynq "Запустить исполнение тестов на устройстве? " answer
						if [ "${answer}" = y ]; then run_tests; else show_line; fi
						;;
					* ) ;;
				esac
			else
				echo -e "${PREF}Но его архитектура ${BLUE}${ARCH_BUILD//-*/}${NOCL} отлична от текущей ${BLUE}${dev_arch}${NOCL}. Копирование ${RED}пропускаем!${NOCL}"
			fi

		else
			echo -e "${PREF}Устройство по адресу ${GREEN}${dev_ip}:${dev_port}${NOCL} недоступно, ${RED}пропускаем!${NOCL}"
		fi
	done

}
