#! /usr/bin/env bash

#-------------------------------------------------------------------------------
# Copyright (c) 2022.
# Все права защищены.
#
# Автор: Zeleza
# Email: mail @ zeleza точка ru
#
# Все права защищены.
#
# Продукт распространяется под лицензией Apache License 2.0
# Текст лицензии и его основные положения изложены на русском
# и английском языках, по ссылкам ниже:
#
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.ru
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.en
#
# Перед копированием, использованием, передачей или изменением
# любой части настоящего кода обязательным условием является
# прочтение и неукоснительное соблюдение всех, без исключения,
# статей, лицензии Apache License 2.0 по вышеуказанным ссылкам.
#-------------------------------------------------------------------------------
DEV_CONFIG_NAME=dev.conf
DEV_MANIFEST_DIR_NAME=Makefiles
DEV_CONFIG_FILE="${1}"/"${DEV_CONFIG_NAME}"
. "${DEV_CONFIG_FILE}"
set -e

RED="\033[1;31m";
GREEN="\033[1;32m";
BLUE="\033[36m";
YELLOW="\033[33m";
NOCL="\033[m";
PREF='>> '
APPS_ROOT=/apps
#-------------------------------------------------------------------------------
# Данные учетной записи от имени которой собираем пакет
#-------------------------------------------------------------------------------
USER=master; GROUP=staff; U_ID=5001; G_ID=5001

#-------------------------------------------------------------------------------
#  Создаем папку если ее нет
#-------------------------------------------------------------------------------
mkdir_when_not(){
    [ -d "${1}" ] || mkdir -p "${1}"
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_ynq() {
    header="${1}"
#	в случае, если встретиться слово с корнем "удал", то цвет заголовка - красный
	while true; do
		echo -en "${header}"
		read -r ynq
		case "${ynq}" in
			[Yy]* ) eval "${2}=y"; break; ;;
			[NnQq]* ) eval "${2}=n"; break; ;;
			     *) echo -e "Пожалуйста ответьте на вопрос 'Y' - да или 'N' - нет, Q - выход"
			;;
		esac
	done
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - максимальное число позиций в списке
# 	 $3- переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_choice(){

    header="${1}";
    max_count=${2}

    while true; do
        echo -n "${header} "
        read -r choice
        case "${choice}" in
            [1-"${max_count}"] ) eval "${3}=${choice}"; break; ;;
            [Qq]* ) eval "${3}=q"; break; ;;
                 *) echo -e "Пожалуйста введите число от 1 до ${max_count} или Q для выхода."
            ;;
        esac
    done


}
#-------------------------------------------------------------------------------
# Печатаем строку из 100  знаков равно
#-------------------------------------------------------------------------------
show_line(){
  printf '=%.s' {1..100} && printf '\n'
}

#-------------------------------------------------------------------------------
# Получаем имя приложения из названия корневой папки
#-------------------------------------------------------------------------------
APP_NAME=$(pwd | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)
#-------------------------------------------------------------------------------
# Получаем необходимую информацию о версии пакета
#-------------------------------------------------------------------------------
get_version_part(){
	value=${1}
	cat < "${DEV_CONFIG_FILE}" | grep "${value}" | cut -d'=' -f2 | tr -d ' '
}

PACKAGE_VERSION=$(get_version_part PACKAGE_VERSION)
PACKAGE_STAGE=$(get_version_part PACKAGE_STAGE)
PACKAGE_RELEASE=$(get_version_part PACKAGE_RELEASE)

if [ -n "${PACKAGE_STAGE}" ]; then FULL_VERSION="${PACKAGE_VERSION} ${PACKAGE_STAGE} ${PACKAGE_RELEASE}"; else FULL_VERSION="${PACKAGE_VERSION} ${PACKAGE_RELEASE}"; fi

#-------------------------------------------------------------------------------
# Получаем значение из скрытого файла конфигурации
#-------------------------------------------------------------------------------
get_config_value(){
  cat < "${DEV_CONFIG_FILE}" | grep -E "^${1}=" | cut -d'=' -f2
}

#-------------------------------------------------------------------------------
# Получаем имя приложения из названия корневой папки
#-------------------------------------------------------------------------------
APP_NAME=$(echo "${BASEDIR}" | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)
#-------------------------------------------------------------------------------
# Получаем тип архитектуры процессора роутера
#-------------------------------------------------------------------------------
get_router_arch(){
    cat < "${APPS_ROOT}/entware/package/utils/${APP_NAME}/Makefile" \
    	| grep -v '#' | sed -n 's/\(^.*PKGARCH:=\)\(.*\)$/\2/p'
}

#-------------------------------------------------------------------------------
# Получаем имя пакета для сборки
#-------------------------------------------------------------------------------
get_full_package_version(){
	if [ -n "${PACKAGE_STAGE}" ] ; then stg="-${PACKAGE_STAGE}"; else stg=""; fi
	if [ -n "${PACKAGE_RELEASE}" ] ; then rel="-${PACKAGE_RELEASE}"; else rel=""; fi
	echo "${PACKAGE_VERSION}${stg}${rel}"
}


#-------------------------------------------------------------------------------
# Получаем имя пакета ipk файла для сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_name(){
	echo "${APP_NAME}_$(get_full_package_version)_${ARCH_BUILD}.ipk"
}

#-------------------------------------------------------------------------------
# Получаем полный путь до пакета сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_file(){

    echo "${APPS_ROOT}/entware/bin/targets/${ARCH_BUILD}/generic-glibc/packages/$(get_ipk_package_name)"
}


#-------------------------------------------------------------------------------
# Осуществляем проверку на доступность IP или доменного имени
#-------------------------------------------------------------------------------
is_ip_or_host_alive(){
    ping -q -w3 "${1}" &>/dev/null
}
#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root' || echo "${HOME}")
	key_file_pub="${key_path}/.ssh/${key_name}.pub"
	key_file_prv="${key_path}/.ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Копируем публичный ключ на роутер
#-------------------------------------------------------------------------------
copy_ssh_keys_to_router(){
	# если ключи отсутствуют на NAS
	echo "${PREF}Копируем ключи на роутер ${ROUTER_IP} порт ${PORT}..."
	ssh -p "${PORT}" "root@${ROUTER_IP}" "echo \"$(cat "$(get_key_file)")\" >> /opt/root/.ssh/authorized_keys"
	show_line
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим удаление и установку пакета
#-------------------------------------------------------------------------------
run_reinstalation_on_router(){
	ssh -p "${PORT}" "root@${ROUTER_IP}" 'opkg remove '"${APP_NAME}"
	cmd='[ -d /opt/packages ] || mkdir /opt/packages; opkg install /opt/packages/'"$(get_ipk_package_name)"
	ssh -p "${PORT}" "root@${ROUTER_IP}" "${cmd}" #<<< 2
}

#-------------------------------------------------------------------------------========================================
#
# 	Функции которая меняет крайнюю версию пакета в файлах собираемого пакета
# 	на основе данных из файла ./version
#
#-------------------------------------------------------------------------------========================================
change_version_in_package(){
	sed -i "s/^\(APP_VERSION=\).*/\1${PACKAGE_VERSION}/g" \
		"${APPS_ROOT}"/entware/package/utils/"${APP_NAME}"/files/bin/"${APP_NAME}"
	sed -i "s/^\(APP_RELEASE=\).*/\1${PACKAGE_STAGE}-${PACKAGE_RELEASE}/g" \
		"${APPS_ROOT}"/entware/package/utils/"${APP_NAME}"/files/bin/"${APP_NAME}"
}

#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root/.' || echo "${HOME}/.")
	key_file_pub="${key_path}ssh/${key_name}.pub"
	key_file_prv="${key_path}ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Копируем публичный ключ на роутер
#-------------------------------------------------------------------------------
copy_ssh_keys_to_router(){
	# если ключи отсутствуют на NAS
	echo "${PREF}Копируем ключи на роутер ${ROUTER_IP} порт ${PORT}..."
	ssh -p "${PORT}" "root@${ROUTER_IP}" "echo \"$(cat "$(get_key_file)")\" >> /opt/root/.ssh/authorized_keys"
	show_line
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим копирование собранного пакета на роутер
#-------------------------------------------------------------------------------
copy_app_to_router(){

# 	Проверяем есть ли ключ на роутере
	docker_key=$(cat < "$(get_key_file)")
	ssh -p "${PORT}" "root@${ROUTER_IP}" 'cat /opt/root/.ssh/authorized_keys' | grep -q "${docker_key}" \
	|| copy_ssh_keys_to_router
	echo "${PREF}Загрузка пакета на роутер и его последующая установка..."
	show_line
	ssh -p "${PORT}" "root@${ROUTER_IP}" '[ -d /opt/packages ] || mkdir -p /opt/packages'
	app_tar_name=$(get_ipk_package_name)
	ssh -p "${PORT}" "root@${ROUTER_IP}" 'rm -f '"/opt/packages/${app_tar_name}" #&> /dev/null
	scp -P "${PORT}" "${app_tar_name}" "root@${ROUTER_IP}:/opt/packages/${app_tar_name}"
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запускаем тесты на роутере из контейнера
#-------------------------------------------------------------------------------
run_tests(){
    cd "${APPS_ROOT}/${APP_NAME}"/tests || exit 1
    ./tests.run
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запрашиваем разрешение на запуск тестов на роутере из контейнера
#-------------------------------------------------------------------------------
ask_run_tests(){
    answer=''; read_ynq "Запустить тесты прямо сейчас [Y/N/Q]? " answer
    [ "${answer}" = y ] && run_tests
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Вычисляем время между двумя временами в секундах
# и выводим время в виде ЧЧ:MM:CC
#-------------------------------------------------------------------------------
time_diff(){
    one_time=${1}
    two_time=${2}

    diff_sec=$((two_time - one_time))
    dd=$((diff_sec/86400))
    hh=$((diff_sec / 3600))
    mm=$((diff_sec / 60))
    ss=$((diff_sec % 60))

    if [ "${dd}" = 0 ]; then DD=''; else DD="${dd} дн. "; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] ; then HH=''; else HH=" ${hh} ч."; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] && [ "${mm}" = 0 ] ; then MM=''; else MM=" ${mm} мин."; fi

    echo "${DD}${HH}${MM} ${ss} сек."
}

copy_and_install_package(){

    tests_ask=${1:-yes}
    # проверяем на доступность ip роутера
    if is_ip_or_host_alive "${ROUTER_IP}"; then
        # копируем собранный пакет на роутер
        copy_app_to_router
        run_reinstalation_on_router
        # Запускаем тесты
        case "${tests_ask}" in
            YES|Yes|yes|y ) run_tests ;;
            ASK|Ask|ask|a )
                answer=''; read_ynq "Запустить исполнение тестов? " answer
                [ "${answer}" = y ] run_tests ;;
            * ) ;;
        esac

    else
        echo -e "${RED}${PREF}IP адрес устройства '${ROUTER_IP}' - НЕ доступен!${NOCL}"
        echo -e "${RED}${PREF}Установку и тестирование пакета пропускаем!${NOCL}"
    fi

}