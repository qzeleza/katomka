#! /usr/bin/env bash

#-------------------------------------------------------------------------------
# Copyright (c) 2022.
# Все права защищены.
#
# Автор: Zeleza
# Email: mail @ zeleza точка ru
#
# Все права защищены.
#
# Продукт распространяется под лицензией Apache License 2.0
# Текст лицензии и его основные положения изложены на русском
# и английском языках, по ссылкам ниже:
#
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.ru
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.en
#
# Перед копированием, использованием, передачей или изменением
# любой части настоящего кода обязательным условием является
# прочтение и неукоснительное соблюдение всех, без исключения,
# статей, лицензии Apache License 2.0 по вышеуказанным ссылкам.
#-------------------------------------------------------------------------------

DEV_MANIFEST_DIR_NAME=''
DEV_CONFIG_FILE="${1}/build.conf"
. "${DEV_CONFIG_FILE}"
set -e

RED="\033[1;31m";
GREEN="\033[1;32m";
BLUE="\033[36m";
YELLOW="\033[33m";
NOCL="\033[m";
PREF='>> '
APPS_ROOT=/apps

#-------------------------------------------------------------------------------
# Данные учетной записи от имени которой собираем пакет
#-------------------------------------------------------------------------------
USER=master; GROUP=staff; U_ID=5001; G_ID=5001

#-------------------------------------------------------------------------------
#  Создаем папку если ее нет
#-------------------------------------------------------------------------------
mkdir_when_not(){
    [ -d "${1}" ] || mkdir -p "${1}"
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_ynq() {
    header="${1}"
#	в случае, если встретиться слово с корнем "удал", то цвет заголовка - красный
	while true; do
		echo -en "${header}"
		read -r ynq
		case "${ynq}" in
			[Yy]* ) eval "${2}=y"; break; ;;
			[NnQq]* ) eval "${2}=n"; break; ;;
			     *) echo -e "Пожалуйста ответьте на вопрос 'Y' - да или 'N' - нет, Q - выход"
			;;
		esac
	done
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - максимальное число позиций в списке
# 	 $3 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_choice(){

    header="${1}";
    max_count=${2}

    while true; do
        echo -n "${header} "
        read -r choice
        case "${choice}" in
            [1-"${max_count}"] ) eval "${3}=${choice}"; break; ;;
            [Qq]* ) eval "${3}=q"; break; ;;
                 *) echo -e "Пожалуйста введите число от 1 до ${max_count} или Q для выхода."
            ;;
        esac
    done


}

#-------------------------------------------------------------------------------
# Печатаем строку из 100 знаков равно
#	$1 - символ который печатаем (по умолчанию '-')
#	$2 - число пробелов спереди  строки (по умолчанию '0')
#	$3 - длинна строки (по умолчанию '100' символов )
#
#-------------------------------------------------------------------------------
print_line_sim(){
	sim=${1:--}; nspaces=${2:-0}; len=${3:-100}
	printf "%${nspaces}s"
	printf "%$((len - nspaces))s\n" | tr ' ' "${sim}"
}

#-------------------------------------------------------------------------------
# Печатаем строку из 100  знаков равно
#-------------------------------------------------------------------------------
show_line(){
  printf '=%.s' {1..100} && printf '\n'
}


#-------------------------------------------------------------------------------
# Получаем необходимую информацию о версии пакета
#-------------------------------------------------------------------------------
get_version_part(){
	value=${1}
	cat < "${DEV_CONFIG_FILE}" | grep "${value}" | cut -d'=' -f2 | tr -d ' '
}

PACKAGE_VERSION=$(get_version_part PACKAGE_VERSION)
PACKAGE_STAGE=$(get_version_part PACKAGE_STAGE)
PACKAGE_RELEASE=$(get_version_part PACKAGE_RELEASE)

if [ -n "${PACKAGE_STAGE}" ]; then FULL_VERSION="${PACKAGE_VERSION} ${PACKAGE_STAGE} ${PACKAGE_RELEASE}"; else FULL_VERSION="${PACKAGE_VERSION} ${PACKAGE_RELEASE}"; fi

#-------------------------------------------------------------------------------
# Получаем значение из скрытого файла конфигурации
#-------------------------------------------------------------------------------
get_config_value(){
  cat < "${DEV_CONFIG_FILE}" | grep -E "^${1}=" | cut -d'=' -f2
}

#-------------------------------------------------------------------------------
# Получаем имя приложения из названия корневой папки
#-------------------------------------------------------------------------------
APP_NAME=$(echo "${BASEDIR}" | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)

#-------------------------------------------------------------------------------
# Получаем имя пакета для сборки
#-------------------------------------------------------------------------------
get_full_package_version(){
	if [ -n "${PACKAGE_STAGE}" ] ; then stg="-${PACKAGE_STAGE}"; else stg=""; fi
	if [ -n "${PACKAGE_RELEASE}" ] ; then rel="-${PACKAGE_RELEASE}"; else rel=""; fi
	echo "${PACKAGE_VERSION}${stg}${rel}"
}


#-------------------------------------------------------------------------------
# Получаем имя пакета ipk файла для сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_name(){
	echo "${APP_NAME}_$(get_full_package_version)_${ARCH_BUILD}.ipk"
}

#-------------------------------------------------------------------------------
# Получаем полный путь до пакета сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_file(){

    echo "${APPS_ROOT}/entware/bin/targets/${ARCH_BUILD}/generic-glibc/packages/$(get_ipk_package_name)"
}


#-------------------------------------------------------------------------------
# Осуществляем проверку на доступность IP или доменного имени
#-------------------------------------------------------------------------------
is_ip_or_host_alive(){
    ping -q -w3 "${1}" &>/dev/null
}
#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root' || echo "${HOME}")
	key_file_pub="${key_path}/.ssh/${key_name}.pub"
	key_file_prv="${key_path}/.ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим удаление и установку пакета
#-------------------------------------------------------------------------------
run_reinstalation_on_router(){
	dev_ip=${1}; dev_port=${2}

	ssh -p "${dev_port}" "root@${dev_ip}" 'opkg remove '"${APP_NAME}"
	cmd='[ -d /opt/packages ] || mkdir /opt/packages; opkg install /opt/packages/'"$(get_ipk_package_name)"
	ssh -p "${dev_port}" "root@${dev_ip}" "${cmd}" #<<< 2
}

#-------------------------------------------------------------------------------========================================
#
# 	Функции которая меняет крайнюю версию пакета в файлах собираемого пакета
# 	на основе данных из файла ./version
#
#-------------------------------------------------------------------------------========================================
change_version_in_package(){
	sed -i "s/^\(APP_VERSION=\).*/\1${PACKAGE_VERSION}/g" \
		"${APPS_ROOT}"/entware/package/utils/"${APP_NAME}"/files/bin/"${APP_NAME}"
	sed -i "s/^\(APP_RELEASE=\).*/\1${PACKAGE_STAGE}-${PACKAGE_RELEASE}/g" \
		"${APPS_ROOT}"/entware/package/utils/"${APP_NAME}"/files/bin/"${APP_NAME}"
}

#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root/.' || echo "${HOME}/.")
	key_file_pub="${key_path}ssh/${key_name}.pub"
	key_file_prv="${key_path}ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Копируем публичный ключ на роутер
#-------------------------------------------------------------------------------
copy_ssh_keys_to_router(){
	dev_ip=${1}; dev_port=${2}

	# если ключи отсутствуют на NAS
	echo "${PREF}Копируем ключи на роутер ${dev_ip} порт ${dev_port}..."
	ssh -p "${dev_port}" "root@${dev_ip}" "echo \"$(cat "$(get_key_file)")\" >> /opt/root/.ssh/authorized_keys"
	show_line
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим копирование собранного пакета на роутер
#-------------------------------------------------------------------------------
copy_app_to_router(){
	dev_ip=${1}; dev_port=${2}

	echo "${PREF}Копируем пакет на устройство и производим его установку..."
	show_line
#	создаем папку на устройстве для хранения упакованного пакета
	ssh -p "${dev_port}" "root@${dev_ip}" '[ -d /opt/packages ] || mkdir -p /opt/packages'
	app_tar_name=$(get_ipk_package_name)
#	удаляем предыдущий файл этой же версии пакета, если он там был и перемещаем его из контейнера на устройство
	ssh -p "${dev_port}" "root@${dev_ip}" 'rm -f '"/opt/packages/${app_tar_name}" #&> /dev/null
	scp -P "${dev_port}" "${PACKAGES_PATH}/${app_tar_name}" "root@${dev_ip}:/opt/packages/${app_tar_name}"
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Получаем архитектуру текущего устройства
#-------------------------------------------------------------------------------
get_device_arch(){
	dev_ip=${1}; dev_port=${2}

	cmd_get_arch='grep "arch" /opt/etc/entware_release | cut -f2 -d"="'
	ssh -p "${dev_port}" "root@${dev_ip}" "${cmd_get_arch}"
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запускаем тесты на роутере из контейнера
#-------------------------------------------------------------------------------
run_tests(){
    cd "${APPS_ROOT}/${APP_NAME}"/${}/${DEV_TESTS_NAME} || exit 1
    ./tests.run
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запрашиваем разрешение на запуск тестов на роутере из контейнера
#-------------------------------------------------------------------------------
ask_run_tests(){
    answer=''; read_ynq "Запустить тесты прямо сейчас [Y/N/Q]? " answer
    [ "${answer}" = y ] && run_tests
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Вычисляем время между двумя временами в секундах
# и выводим время в виде ЧЧ:MM:CC
#-------------------------------------------------------------------------------
time_diff(){
    one_time=${1}
    two_time=${2}

    diff_sec=$((two_time - one_time))
    dd=$((diff_sec/86400))
    hh=$((diff_sec / 3600))
    mm=$((diff_sec / 60))
    ss=$((diff_sec % 60))

    if [ "${dd}" = 0 ]; then DD=''; else DD="${dd} дн. "; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] ; then HH=''; else HH=" ${hh} ч."; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] && [ "${mm}" = 0 ] ; then MM=''; else MM=" ${mm} мин."; fi

    echo "${DD}${HH}${MM} ${ss} сек."
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
#
# 	Копируем пакет на роутер и производим его установку
#
# 	$1 - в случае значения ask - выводим вопрос о проведении тестов,
#	   		 при иных значениях - тесты пропускаем
#
#-------------------------------------------------------------------------------
copy_and_install_package(){

    tests_ask=${1:-no}

    for dev in ${ROUTER_LIST} ; do
#    	получаем адрес и порт (по умолчанию - 222)
    	dev_ip=$(echo "${dev}" | cut -d':' -f1 )
    	dev_port=$(echo "${dev}" | cut -d':' -f2)
    	[ "${dev_port}" = "${dev_ip}" ] && dev_port=222

		# проверяем на доступность ip роутера
		if is_ip_or_host_alive "${dev_ip}"; then

			echo -e "${PREF}Устройство по адресу ${GREEN}${dev_ip}:${dev_port}${NOCL} доступно!"
			# 	Проверяем есть ли ключ на роутере
			docker_key=$(cat < "$(get_key_file)")
			ssh -p "${dev_port}" "root@${dev_ip}" 'cat /opt/root/.ssh/authorized_keys' | grep -q "${docker_key}" || {
					show_line
					copy_ssh_keys_to_router "${dev_ip}" "${dev_port}"
			}

	#    	текущая архитектура на устройстве
			dev_arch=$(get_device_arch "${dev_ip}" "${dev_port}")
	#    	текущая архитектура в контейнере (просто название без версии )
			container_arch=$(echo "${ARCH_BUILD}" | sed -n 's|^\([a-zA-Z]\{4,\}\)[0-9]\{0,2\}\(-[0-9]\{1,2\}.[0-9]\{1,2\}\).*|\1|p')

			if [ "${container_arch}" = "${dev_arch}" ]; then
			# копируем собранный пакет на роутер
			copy_app_to_router "${dev_ip}" "${dev_port}"
#				запускаем установку пакета
			run_reinstalation_on_router "${dev_ip}" "${dev_port}"
			show_line
				# Запускаем тесты
				case "${tests_ask}" in
					YES|Yes|yes|y ) run_tests ;;
					ASK|Ask|ask|a )
						answer=''; read_ynq "Запустить исполнение тестов? " answer
						[ "${answer}" = y ] && run_tests ;;
					* ) ;;
				esac
			else
				echo -e "${PREF}Но его архитектура ${BLUE}${ARCH_BUILD//-*/}${NOCL} отлична от текущей ${BLUE}${dev_arch}${NOCL}. Копирование ${RED}пропускаем!${NOCL}"
			fi

		else
			echo -e "${PREF}Устройство по адресу ${GREEN}${dev_ip}:${dev_port}${NOCL} не доступно, ${RED}пропускаем!${NOCL}"
		fi
	done

}